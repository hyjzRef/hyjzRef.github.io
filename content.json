{"meta":{"title":"黑夜·镜子的博客","subtitle":"大道至简，谦卑以学","description":"愿我们每一次相逢，都以幸福共始终","author":"hyjzRef","url":"http://hyjzref.github.io"},"pages":[],"posts":[{"title":"游戏对我而言究竟是何物？","date":"2018-07-10T16:42:00.000Z","path":"posts/2018-07-11/16.游戏对我而言究竟是何物？/","text":"我总是在寻求一个能让我无条件信任的信念，我最近才发现自己有这个倾向。 诸多次我希望能从游戏中得到快乐、发现美，把它当做我的北极星，但事实上它却是一座缥缈的海市蜃楼，追寻它的过程能让人心跳澎湃、充满难以掩盖的兴奋感，仿佛得到了它就能得到这世间的真理一般。噢，如果这是真的那该有多好！ 正如发现海市蜃楼的虚假之后兴奋会立马消失，那份激情在离开游戏后就将不复存在，带来的副作用就是假象对比——会不自觉地把游戏中的乐趣代入到生活之中，你明明知道生活不会有这种乐趣但就是会不自觉的去代入，结论就是对比发现生活多么的无趣。这样的后果与我的初衷是恰恰相反的，我不得不向自己的初心发出质疑：做游戏真的还是我的理想吗？ 在自己心中依旧放不下游戏，它应该还是我的理想吧。也有可能哪一天放下了。 这是一次可怕的质疑，一旦推翻了初心后果我不敢想象。这是最终手段，我不应该轻易选择它，我尝试从其它节点来解决问题。 副作用能不能消除呢？消除副作用听起来很不错，但转念一想这其实是无为之举，这相当于否定了游戏这个过程，有这个精力浪费时间还不如躺床上去睡一觉。 那有没有合适的手段把副作用抵消甚至正化？我回想了一下自己的游戏过往，脑海一闪而过一个词，我抓住它之后发现它叫角色扮演，英文名叫cosplay，这个手段是更进一步的把游戏代入现实的自我来获得乐趣。（说起来好笑我以前称它为自我欺骗，因为我无法理解这个行为并且还觉得它很蠢）似乎还有其它手段，我努力好几次才抓住它，它是人际，以游戏作为媒介从人际交往中获得乐趣。似乎还有其它手段，但是这次我抓不住它们了。 停手休息下，但脚步不能停，这两件装备，还需自己穿上试试合不合身。","slug":"16.游戏对我而言究竟是何物？","updated":"2018-07-10T16:59:49.490Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2018-07-11/16.游戏对我而言究竟是何物？/","excerpt":"","categories":[{"name":"思","slug":"思","permalink":"http://hyjzref.github.io/categories/思/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://hyjzref.github.io/tags/思考/"}]},{"title":"[CSharp]常用数据结构总结","date":"2018-03-29T07:47:00.000Z","path":"posts/2018-03-29/15.[CSharp]常用数据结构总结/","text":"空闲下来花了几个小时时间复习整理了一下C#的常用数据结构，帮助自己以后回忆一下，全是实例。包括： 1.Array 2.ArrayList 3.List&lt;T&gt; 4.LinkedList&lt;T&gt; 5.Queue&lt;T&gt; 6.Stack&lt;T&gt; 7.Dictionary&lt;T&gt; 8.Hashtable 9.HashMap（.Net中没有） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;class Program&#123;static void Main(string[] args)&#123; // 1 Array，有如下特点： // 1.)数组存储在连续内存上 // 2.)数组中内容类型相同 // 3.)数组长度无法改变 // 1.1 新建Array int[] array1 = new int[5]; int[] array2 = &#123; 0, 1 &#125;; int[] array3 = new int[] &#123; 2, 3 &#125;; // 1.2 遍历访问Array Console.WriteLine(\"1.2.1) 使用for循环遍历array2\"); for (var i = 0; i &lt; array2.Length; i++) &#123; Console.WriteLine(array2[i]); &#125; Console.WriteLine(\"1.2.2) 使用foreach循环遍历array2\"); foreach (var a in array2) &#123; Console.WriteLine(a); &#125; // 2 ArrayList,特点: // 1.)数组中内容类型都为Object,类型不安全，有装箱拆箱操作 // 2.)数组长度为动态 // 2.1 新建ArrayList ArrayList arraylist1 = new ArrayList(); arraylist1.Add(123); arraylist1.Add(\"abc\"); arraylist1.Add(456); // 2.2 遍历访问 Console.WriteLine(\"2.2) 遍历访问arraylist2\"); for (var i = 0; i &lt; arraylist1.Count; i++) &#123; Console.Write(arraylist1[i].ToString() + '|'); &#125; // 2.3 删除元素 arraylist1.RemoveAt(1); // 2.4 清空元素 //arraylist1.Clear(); // 2.5 转换为数组 object[] arrayObj = (object[])arraylist1.ToArray(typeof(object)); // 3 List&lt;T&gt;，代替ArrayList经常被使用，特点： // 1.)继承自IList，支持泛型，所以类型转换是安全的 // 2.)数组长度为动态 // 3.1 新建List List&lt;string&gt; list1 = new List&lt;string&gt;(); string[] strArray = &#123; \"a\", \"b\", \"c\", \"d\" &#125;; List&lt;string&gt; list2 = new List&lt;string&gt;(strArray); // 3.2 遍历访问 Console.WriteLine(\"\"); Console.WriteLine(\"3.2) 遍历访问list2\"); for (var i = 0; i &lt; list2.Count; i++) &#123; Console.Write(list2[i] + '|'); &#125; // 3.3 添加元素 list2.Add(\"e\"); // 3.4 删除元素 list2.Remove(\"a\"); // 3.5 是否包含元素 Console.WriteLine(\"\"); Console.WriteLine(\"3.5) list2中是否包含'b':\" + list2.Contains(\"b\")); // 3.6 Find 查找元素，找到第一个匹配项时结束，算是3.5的升级版 string result1 = list2.Find(str =&gt; str == \"c\"); string result2 = list2.Find(str =&gt; &#123; if (str == \"c\") return true; else return false; &#125;); Console.WriteLine(\"3.6) list2中查找'c':\" + result2); // 3.7 查找元素序号 Console.WriteLine(\"3.7) list2中查找'c'的序号:\" + list2.IndexOf(\"c\")); // 3.8 清空元素 //list2.Clear(); // 3.9 TrueForAll 检查是否所有元素都满足条件 bool result3 = list2.TrueForAll(str =&gt; &#123; if (str is string) return true; else return false; &#125;); Console.WriteLine(\"3.9) list2是否所有元素都为string:\" + result3); // 3.10 Take 取List中部分数据 IEnumerable&lt;string&gt; takeList = list2.Take(2); Console.WriteLine(\"3.10) 取出list2中前两个数据:\"); foreach(string str in takeList) &#123; Console.Write(str + \"|\"); &#125; Console.WriteLine(\"\"); // 3.11 Where 检查并返回所有满足条件的元素 IEnumerable&lt;string&gt; whereList = list2.Where(str =&gt; &#123; if (str == \"c\" || str == \"d\") return true; else return false; &#125;); Console.WriteLine(\"3.11) 取出list2中为'c'或者'd'的元素:\"); foreach (string str in whereList) &#123; Console.Write(str + \"|\"); &#125; Console.WriteLine(\"\"); // 3.12 转换为数组 string[] strArray2 = list2.ToArray(); // 4 LinkedList&lt;T&gt;，又叫双向链表，特点： // 1.)每个元素都含有上一个元素和下一个元素的位置，首尾除外 // 2.)增删元素非常迅速，但查找元素并不快 // 3.)支持泛型，类型安全 // 4.1 创建链表 LinkedList&lt;string&gt; linkList1 = new LinkedList&lt;string&gt;(strArray); // 4.2 添加元素 linkList1.AddLast(\"e\"); // 4.3 遍历元素 Console.WriteLine(\"4.3) 遍历linkList1中的元素:\"); foreach (string str in linkList1) &#123; Console.Write(str + \"|\"); &#125; Console.WriteLine(\"\"); // 4.4 取出元素 LinkedListNode&lt;string&gt; firstLinkedNode = linkList1.First; LinkedListNode&lt;string&gt; lastLinkedNode = linkList1.Last; // 4.5 查找元素 LinkedListNode&lt;string&gt; resultLinkedNode = linkList1.Find(\"e\"); Console.WriteLine(\"4.5) 查找linkList1中的'e':\" + resultLinkedNode.Value); // 4.6 删除元素 Console.WriteLine(\"4.6) 删除linkList1中的'e':\" + linkList1.Remove(\"e\")); // 4.7 是否包含元素 Console.WriteLine(\"4.7) linkList1中是否有'e':\" + linkList1.Contains(\"e\")); // 4.8 清空元素 linkList1.Clear(); // 5 Queue&lt;T&gt;，又叫队列，特点： // 1.)元素存放顺序按照先进先出原则 // 2.)支持泛型，类型安全 // 5.1 创建队列 Queue&lt;string&gt; queue1 = new Queue&lt;string&gt;(strArray); // 5.2 添加元素,只能加在末尾 queue1.Enqueue(\"e\"); // 5.3 遍历元素，一般来说队列和堆栈都不需要遍历 Console.WriteLine(\"5.3) 遍历linkList1中的元素:\"); foreach (string str in queue1) &#123; Console.Write(str + \"|\"); &#125; Console.WriteLine(\"\"); // 5.4 获取开头的元素，并且移出队列 string lastQueueNode = queue1.Dequeue(); Console.WriteLine(\"5.4) 获取并移除queue1中开头的元素:&#123;0&#125;\",lastQueueNode); // 5.5 获取开头的元素，但不把它移出队列 string lastQueueNode2 = queue1.Peek(); Console.WriteLine(\"5.5) 获取queue1中开头的元素:&#123;0&#125;\", lastQueueNode2); // 5.6 拷贝一份数据到数组 string[] toExchangeArray = new string[queue1.Count]; queue1.CopyTo(toExchangeArray, 0); // 6 Stack&lt;T&gt;，又叫堆栈，特点： // 1.)元素存放顺序按照先进后出原则 // 2.)支持泛型，类型安全 // 6.1 创建堆栈 Stack&lt;string&gt; stack1 = new Stack&lt;string&gt;(strArray); // 6.2 添加元素，只能加在栈顶 stack1.Push(\"e\"); // 6.3 取出并且移出栈顶的元素 string firstStackNode = stack1.Pop(); // 6.4 取出栈顶的元素 string firstStackNode2 = stack1.Peek(); // 6.5 拷贝一份数据到数组 string[] toExchangeArray2 = new string[stack1.Count]; stack1.CopyTo(toExchangeArray, 0); // 7 Dictionary&lt;T&gt;，中文叫做字典，特点： // 1.)每一组数据为了一个键值对，支持泛型，为类型安全的 // 2.)任何键都是唯一的 // 3.)字典长度为动态的 // 4.)内部使用哈希表存储，内存不是连续的区域，但遍历时会按照Add的顺序排列 // 5.)它是非线程安全的，若要在多线程中读取，请使用HashTable // 7.1 创建Dictionary Dictionary&lt;string, string&gt; dic1 = new Dictionary&lt;string, string&gt;(); // 7.2 添加元素 dic1.Add(\"a\", \"abc\"); dic1.Add(\"b\", \"bcd\"); dic1.Add(\"c\", \"cde\"); dic1.Add(\"d\", \"def\"); // 7.3 删除元素 dic1.Remove(\"d\"); // 7.4 按键值对遍历访问 Console.WriteLine(\"7.4) 根据键值对遍历字典中的元素\"); foreach(KeyValuePair&lt;string, string&gt; pair in dic1) &#123; Console.Write(pair.Key + \",\" + pair.Value + \"|\"); &#125; Console.WriteLine(\"\"); // 7.5 按键遍历访问 Console.WriteLine(\"7.5) 根据键遍历字典中的Key值\"); Dictionary&lt;string, string&gt;.KeyCollection keys = dic1.Keys; foreach (string key in keys) &#123; Console.Write(key + \"|\"); &#125; Console.WriteLine(\"\"); // 7.6 按值遍历访问 Console.WriteLine(\"7.6) 根据值遍历字典中的Value值\"); Dictionary&lt;string, string&gt;.ValueCollection values = dic1.Values; foreach (string value in values) &#123; Console.Write(value + \"|\"); &#125; Console.WriteLine(\"\"); // 7.7 是否包含键Key值 Console.WriteLine(\"7.7) dic1中是否包含'a':\" + dic1.ContainsKey(\"a\")); // 7.8 字典长度 Console.WriteLine(\"7.8) dic1的长度为:\" + dic1.Count); // 7.9 根据Key值获取Value值 string value2; dic1.TryGetValue(\"a\", out value2); Console.WriteLine(\"7.9) 'a'的Value为:\" + value2); // 8 Hashtable，又叫哈希表、散列表，基本操作与字典相同，特点： // 1.)每一组数据为了一个键值对，键值对的类型都为object // 2.)任何键都是唯一的 // 3.)哈希表长度为动态的 // 4.)内部使用哈希表存储，内存不是连续的区域，遍历时也不是按照Add的顺序排列 // 5.)它单线程可写，多线程可读，是线程安全的 // 8.1 创建Hashtable Hashtable table1 = new Hashtable(); // 8.2 添加元素 table1.Add(\"a\", \"abc\"); table1.Add(\"b\", \"bcd\"); table1.Add(\"c\", \"cde\"); table1.Add(\"d\", \"def\"); // 8.3 按键值对遍历访问 Console.WriteLine(\"8.3) 根据键值对遍历哈希表中的元素\"); foreach (DictionaryEntry entry in table1) &#123; Console.Write(entry.Key + \",\" + entry.Value + \"|\"); &#125; Console.WriteLine(\"\"); // 8.4 按键遍历访问 Console.WriteLine(\"8.4) 根据键遍历字典中的Key值\"); ICollection keys2 = table1.Keys; foreach (string key in keys2) &#123; Console.Write(key + \"|\"); &#125; Console.WriteLine(\"\"); // 8.5 按值遍历访问 Console.WriteLine(\"8.5) 根据值遍历字典中的Value值\"); ICollection values2 = table1.Values; foreach (string value in values2) &#123; Console.Write(value + \"|\"); &#125; // 9 HashMap，存在于Java语法中，.Net中并没有这个类。其与Hashtable的区别点主要是： // 1.)非同步，线程不安全的 // 2.)可以存Null键和Null值，而Hashtable不可以存Null键 while (true) &#123; &#125;;&#125;&#125;","slug":"15.[CSharp]常用数据结构总结","updated":"2018-05-02T11:25:31.694Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2018-03-29/15.[CSharp]常用数据结构总结/","excerpt":"空闲下来花了几个小时时间复习整理了一下C#的常用数据结构，帮助自己以后回忆一下，全是实例。包括： 1.Array 2.ArrayList 3.List&lt;T&gt; 4.LinkedList&lt;T&gt; 5.Queue&lt;T&gt; 6.Stack&lt;T&gt; 7.Dictionary&lt;T&gt; 8.Hashtable 9.HashMap（.Net中没有）","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://hyjzref.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://hyjzref.github.io/tags/CSharp/"},{"name":"数据结构","slug":"数据结构","permalink":"http://hyjzref.github.io/tags/数据结构/"}]},{"title":"[Unity]Mesh相关类库文档自译","date":"2018-03-03T06:48:00.000Z","path":"posts/2018-03-03/14.[Unity]Mesh相关类库文档自译/","text":"Mesh 网格概述可以通过脚本代码创建或修改Mesh类。 Mesh的属性包括顶点数组和若干个三角形数组 对于每一个顶点，可以有一条法线、两个纹理坐标、颜色和切线。这些都是可选的可以随意删除。所有的顶点信息都分别存储在相同大小的数组中，如果你的mesh有十个顶点，那么你就会有十条法线和其它属性的数组。 以下三种情况你可能会想用可修改的mesh： 1.从零开始创建一个mesh：应该按照下面的顺序a) 指定顶点b) 指定若干个三角形 123456789101112131415using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; public Vector3[] newVertices; public Vector2[] newUV; public int[] newTriangles; void Start() &#123; Mesh mesh = new Mesh(); GetComponent&lt;MeshFilter&gt;().mesh = mesh; mesh.vertices = newVertices; mesh.uv = newUV; mesh.triangles = newTriangles; &#125;&#125; 2.每一帧去修改顶点属性：a) 获取顶点b) 修改它们c) 将它们分配回去12345678910111213141516using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; void Update() &#123; Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh; Vector3[] vertices = mesh.vertices; Vector3[] normals = mesh.normals; int i = 0; while (i &lt; vertices.Length) &#123; vertices[i] += normals[i] * Mathf.Sin(Time.time); i++; &#125; mesh.vertices = vertices; &#125;&#125; 3.不断改变mesh的三角形和顶点：a) 调用Clear进行一个新的开始b) 指定顶点和其它属性c) 指定三角形序列在指定顶点和三角形之前一定要先调用Clear。Unity总是会检查所提供的三角形序列，确认它们是否没有引用越界顶点。而调用Clear再指定顶点和三角形可以确保你永远不会有越界数据。1234567891011121314151617181920using UnityEngine;public class ExampleClass : MonoBehaviour&#123; Vector3[] newVertices; Vector2[] newUV; int[] newTriangles; void Start() &#123; Mesh mesh = GetComponent&lt;MeshFilter&gt;().mesh; mesh.Clear(); // Do some calculations... mesh.vertices = newVertices; mesh.uv = newUV; mesh.triangles = newTriangles; &#125;&#125; 属性bindposes：每一个序号的bind pose指的是相同序号的骨骼。当骨骼在绑骨状态时，bind pose是骨骼的变换矩阵的逆。blendShapeCount：返回这个mesh的blendShape数量。boneWeights：骨骼权重。bounds：mesh的包围体。colors：Mesh的顶点颜色。colors32：Mesh的顶点颜色，使用Color32结构表现会更优异。indexFormat：mesh的索引缓存数据的格式。isReadable：在模型导入后返回”Read/Write Enable”的状态。normals：Mesh的法线。subMeshCount：子Mesh的数量。每一个材质都有三角形列表。tangents：Mesh的切线。triangles：包含Mesh中所有三角形的数组。uv：Mesh的基本纹理坐标。uv2：Mesh的第二纹理坐标，如果存在的话。uv3：Mesh的第三纹理坐标，如果存在的话。uv4：Mesh的第四纹理坐标，如果存在的话。vertexBufferCount：获取Mesh中存在的顶点缓冲区数目（只读）。vertexCount：返回Mesh中顶点的数目（只读）。vertices：返回顶点位置的副本或分配一个新的顶点位置数组。 MeshCollider 网格碰撞器概述你可以用mesh collider在mesh和原型之间做碰撞检测。 属性convex：是否允许mesh使用convex（凸起）碰撞。（Unity默认mesh与原型之间可以发生碰撞，而mesh与mesh之间不会发生碰撞，后者若要碰撞需要指定该属性为true）cookingOptions：用这个选项来设置mesh cooking的特性？inflateMesh：是否允许物理引擎增加mesh的体积以生成更适合物理引擎的凸起mesh。sharedMesh：用于碰撞检测的mesh对象。skinWidth：当启用inflateMesh时，用于决定膨胀系数的上限。 MeshFilter 网格过滤器概述用于获取mesh的一个类。 属性mesh：返回mesh filter的实例化mesh。sharedMesh：返回mesh filter的共享mesh。 MeshRenderer 网格渲染器概述渲染嵌在MeshFilter或TextMesh中的mesh。 属性additionalVertexStreams：这个mesh上的顶点属性会重载或添加属性在mesh renderer的mesh上。 BoneWeight 骨骼权重概述mesh某个顶点的蒙皮骨骼权重。每个蒙皮的顶点最多受四个不同骨骼影响。所有的权重应该相加为1。权重和骨骼序号应该按权重递减顺序确定。如果一个顶点由少于四个骨骼作用，那么剩下的权重应该为0。","slug":"14.[Unity]Mesh相关类库文档自译","updated":"2018-05-02T11:24:44.212Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2018-03-03/14.[Unity]Mesh相关类库文档自译/","excerpt":"Mesh 网格概述可以通过脚本代码创建或修改Mesh类。 Mesh的属性包括顶点数组和若干个三角形数组 对于每一个顶点，可以有一条法线、两个纹理坐标、颜色和切线。这些都是可选的可以随意删除。所有的顶点信息都分别存储在相同大小的数组中，如果你的mesh有十个顶点，那么你就会有十条法线和其它属性的数组。 以下三种情况你可能会想用可修改的mesh： 1.从零开始创建一个mesh：应该按照下面的顺序a) 指定顶点b) 指定若干个三角形 123456789101112131415using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; public Vector3[] newVertices; public Vector2[] newUV; public int[] newTriangles; void Start() &#123; Mesh mesh = new Mesh(); GetComponent&lt;MeshFilter&gt;().mesh = mesh; mesh.vertices = newVertices; mesh.uv = newUV; mesh.triangles = newTriangles; &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"http://hyjzref.github.io/categories/Unity/"}],"tags":[{"name":"Unity文档","slug":"Unity文档","permalink":"http://hyjzref.github.io/tags/Unity文档/"}]},{"title":"[年终总结]2017年年终总结","date":"2018-02-15T12:07:00.000Z","path":"posts/2018-02-15/13.[年终总结]2017年年终总结/","text":"想了半天，实在想不出什么漂亮话来作为开篇词汇。作为从业的第一年，每天工作时间14小时以上每周至少工作80小时以上、项目成为爆款而分得一笔不小的财款、出现了人生的伴侣等等，这些大起大落都没有!!相反地，只有如粗茶淡饭般的生活。 上一年的计划 独立制作一款在手机平台上的游戏Demo上半年使用Unity引擎仿制了童年经典游戏《炸弹人》，除了一些隐藏奖励（例如过第一关之后绕墙边走一圈会出现积分道具）之外实现了全部功能。下半年准备了一个用Cocos2d引擎挖的深坑《尔茄异世界冒险》，结果这个计划才刚刚开始一个月就被放置吃灰了，一方面是工作上的时间占用太多，另一方面是自己又菜又懒，什么时候有能力又有时间的时候再回来挖坑吧~。 在C#/Unity前端上有自己的技术积累在这方面算是过了门槛入了门，但也只是入了门，后续因为公司安排转到了Js/Cocos2d上而不再有精力注重这方面的积累，所以更改为在Cocos2d上的积累，技术上的积累明显不理想，倒是积累了相当多的业务能力。 有自己可复用的类库、框架或架构模型，能够快速开发和广泛适用在这方面没有细致的整理。。。，工作上不需要有过多的人接触架构的开发，新手去做反而会添倒忙，但是工作的时候还是需要去看懂架构的能力。 尝试编写自己的博客，进行独立思考的总结这两部分都做到了，很满足。些许不足的是没有人与自己交流，自己更新的频率还可以更快些，应该达到至少两周一更。 向身边、网络的大牛学习，能编写出复用性强的代码读懂代码是一种能力，自己编写代码又是一种能力，在这一点上需要更多的练习，现阶段的练习太少了。 这一年我干了什么？1.行业上 参与一款海战游戏Demo的开发，但仅做了一些微小的工作（Demo也死在了摇篮之中）； 后来公司转型，开始学习Cocos2d引擎，进入到了棋牌开发业务之中，完整经历了两款棋牌产品的开发、迭代过程； 对游戏行业有了更整体的认识：大概的说，游戏行业已经进入到了腾讯、网易主导的寡头时代，部分大厂还能靠着自家的大产品活着，而中小企业只能靠着抄抄抄勉强活下来。正如知乎姜磊所说： 没有竞争力的公司，就是这个问题下的，那些人所抱怨的那样，不知道做什么游戏有竞争力就抄；不知道怎样能够发挥出团队的创造力就加班；不知道怎样能够获取用户就打擦边球；不知道如何招募到优秀的人就找一些没有竞争力的从业者……而没有竞争力的从业者，则是那些只能待在这些没有竞争力的公司里面，不知道怎样充分利用时间提升自己，于是抱怨行业看不到机会；不知道自己真正为团队为公司为行业创造了什么价值，于是抱怨没有分享到利益；不知道怎样改变自己的工作状态和选择工作环境，于是抱怨行业没有前景…… 2.人生上 年末开始学习绘画插画作为兴趣，尽管现在还在入门临摹阶段，但有朝一日还是希望自己能为喜欢的角色绘制漂亮的插画； 使用时间管理和笔记软件每日总结帮助自己更好的学习与成长。养成记笔记的习惯已经一年半了，从最开始的纸质到现在的笔记软件，看着自己一步步的成长也有所欣慰。 想清楚了自己的人生追求，人生在世，应当有一件对自己最重要的事。我当前最重要的事就是努力提升个人能力。个人能力这个词很笼统，我暂时把它分成两份。一是技术能力，在知识上有广度、深度的积累；在编程上能实现需求；在学习上有获取未知领域知识的能力。二是综合能力，包括前瞻力：思考未来的发展方向、有未来规划的具体方案和步骤；管理能力：对时间和精力进行更合理的分配、对自制力差的行为加强自律；决断力：实际就是心里有数，清楚哪一件事情是最重要，哪一件事可以延后。综合能力是一片极其广阔的海洋，需要不断反思与完善。 这一年我的所得所感1.学而不思则罔，思而不学则殆在编程学习上，“学”可以理解去观摩大神代码和自己去尝试按大神的思路再编写一遍代码，“思”可以理解为去总结与反思自己的不足。回头一看在这一年，自己陷入了思多学少也就是“殆”的情况，这才发现古人诚不欺我也。2.大牛之所以成为大牛仅在于他们真的很热爱技术才会想接触更多技术，而不在于其它运气能力之类东西3.相比找工作更重要的是找对一起工作的人,理想中变的是工作然而不变的是人。4.一味地只完成项目要求自身成长是比较慢的，应该还要注重工作外的学习 明年的计划1.能够开始自己创作插画，一步步慢慢成长2.每两周写一篇博客，什么都可以，但不能粗制滥造，要养成写作的好习惯3.转回unity引擎，参与开发3d游戏4.做一份计划，去一个人享受旅游5.补充名著知识，预计2018年阅读八本名著","slug":"13.[年终总结]2017年年终总结","updated":"2018-05-02T11:24:55.517Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2018-02-15/13.[年终总结]2017年年终总结/","excerpt":"想了半天，实在想不出什么漂亮话来作为开篇词汇。作为从业的第一年，每天工作时间14小时以上每周至少工作80小时以上、项目成为爆款而分得一笔不小的财款、出现了人生的伴侣等等，这些大起大落都没有!!相反地，只有如粗茶淡饭般的生活。 上一年的计划 独立制作一款在手机平台上的游戏Demo上半年使用Unity引擎仿制了童年经典游戏《炸弹人》，除了一些隐藏奖励（例如过第一关之后绕墙边走一圈会出现积分道具）之外实现了全部功能。下半年准备了一个用Cocos2d引擎挖的深坑《尔茄异世界冒险》，结果这个计划才刚刚开始一个月就被放置吃灰了，一方面是工作上的时间占用太多，另一方面是自己又菜又懒，什么时候有能力又有时间的时候再回来挖坑吧~。 在C#/Unity前端上有自己的技术积累在这方面算是过了门槛入了门，但也只是入了门，后续因为公司安排转到了Js/Cocos2d上而不再有精力注重这方面的积累，所以更改为在Cocos2d上的积累，技术上的积累明显不理想，倒是积累了相当多的业务能力。 有自己可复用的类库、框架或架构模型，能够快速开发和广泛适用在这方面没有细致的整理。。。，工作上不需要有过多的人接触架构的开发，新手去做反而会添倒忙，但是工作的时候还是需要去看懂架构的能力。 尝试编写自己的博客，进行独立思考的总结这两部分都做到了，很满足。些许不足的是没有人与自己交流，自己更新的频率还可以更快些，应该达到至少两周一更。 向身边、网络的大牛学习，能编写出复用性强的代码读懂代码是一种能力，自己编写代码又是一种能力，在这一点上需要更多的练习，现阶段的练习太少了。","categories":[{"name":"年终总结","slug":"年终总结","permalink":"http://hyjzref.github.io/categories/年终总结/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://hyjzref.github.io/tags/总结/"}]},{"title":"[电影感想] Into The Wild","date":"2018-01-07T10:00:51.000Z","path":"posts/2018-01-07/12.[电影感想] Into The Wild/","text":"电影里，Alex真是一个具有魔力的人，和他相处过的人都特别喜欢他，我也不例外尽管只单方面见过他。 他是一个聪明人，他懂得在生活里伪装自己成一个理想的社会青年，但是他骨子里却是一个追求真实的人，他讨厌城市里的虚伪，讨厌家庭里的暴力，他厌恶这个社会，他厌恶这个社会里的一切，除了人类。人类制造了这个繁荣的社会，但社会却容不下这个渴求真实的人类。梭罗曾写过 Rather than love,than money,than faith,than fame, than fairness,give me truth不要给我爱、金钱、信念、名望、公平，给我真相 成为流浪者并非是社会抛弃他，而是他的心里已经抛弃了社会，烧掉身上最后的500美元，他获得了自由与真实。他对Ron说过”I mean,the core of man’s spirit comes from new experiences.And there you are,stubborn old man,setting on your butt.”（人的精神核心来自新经验，但你这个倔强的老人，只坐在那里，不愿移动你的屁股）Ron是一个死板而倔强的老头子，常理的锁链禁锢着他的思想大半个世纪，他潜意识选择拒绝接受新事物，Alex的一席话如一把利斧砍在这根锁链上，当他选择爬上坡腰时，年迈的老头子仿佛找回当年的风采。 Alex身上有一种魔力，他让每个和他相处过的人们都喜欢上了他。我没法找到一个词语来确切的形容它，我觉得它应该是，有一股勇气和毅力敢违反常识、规矩去追求真实与自由，这一个行动体将会给人带来了巨大的认知改变。最后，附上Alex生命中最后的一句话 What if I were smiling and running into your arms?Would you see than what I see now?若我微笑跑入你们的臂弯，你们会看见…我现在看见的东西吗？","slug":"12.[电影感想] Into The Wild","updated":"2018-04-20T09:59:37.274Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2018-01-07/12.[电影感想] Into The Wild/","excerpt":"电影里，Alex真是一个具有魔力的人，和他相处过的人都特别喜欢他，我也不例外尽管只单方面见过他。 他是一个聪明人，他懂得在生活里伪装自己成一个理想的社会青年，但是他骨子里却是一个追求真实的人，他讨厌城市里的虚伪，讨厌家庭里的暴力，他厌恶这个社会，他厌恶这个社会里的一切，除了人类。人类制造了这个繁荣的社会，但社会却容不下这个渴求真实的人类。梭罗曾写过","categories":[{"name":"所得所想","slug":"所得所想","permalink":"http://hyjzref.github.io/categories/所得所想/"}],"tags":[{"name":"电影感想","slug":"电影感想","permalink":"http://hyjzref.github.io/tags/电影感想/"}]},{"title":"[Cocos]Cocos2d-html & Tiled 引擎多加载一块瓷砖致使X坐标不正确","date":"2017-10-26T16:07:00.000Z","path":"posts/2017-10-27/11.[Cocos]Cocos2d-html & Tiled 引擎多加载一块瓷砖致使X坐标不正确/","text":"记载一次在 Cocos2d-html 引擎中使用 Tiled 的 Bug 发现和解决。 这是我在 Tiled 中设计的图层：我想加载黑色框中的图像，但是我实际加载出来的是红色框中的图像。这看起来就像是 cocos2d-html 引擎在计算水平位置时多往右加了一个格子的位置 …然后这是在浏览器中的图像：好气啊 愤怒地猜原因：1.可能是图集过大导致的，试过多次将图集的大小减小但是这个问题依然存在。2.我又猜测可能我所选择的压缩格式有问题，尝试选择 zlib、xml 都未能解决问题3.最后在 cocos2d-html 引擎中发现这么一段代码：123456789101112131415// frameworks/cocos2d-html5/cocos2d/tilemap/CCTMXXMLParser.jsparseXMLFile:function (tmxFile, isXmlString) &#123; ... var tileset = new cc.TMXTilesetInfo(); var tileset = new cc.TMXTilesetInfo(); tileset.name = selTileset.getAttribute('name') || \"\"; //TODO need fix //if(this._currentFirstGID === 0)&#123; tileset.firstGid = parseInt(selTileset.getAttribute('firstgid')) || 0; //&#125;else&#123; // tileset.firstGid = this._currentFirstGID; // this._currentFirstGID = 0; //&#125; ...&#125; 抱着试一试的心态将代码里 tileset.firstGid 的默认值从 0 改为 1 后问题解决。发现成功时的心情开心到要起飞(￣▽￣)/ 2017.10.29在论坛上收到了一位大佬的回复，上面的方法似乎仅适用于只使用一块 tileset(图块)时的情形，而cocos官方注释掉的方法应该是能够解决这个问题的，但不知道为什么给注了。。。","slug":"11.[Cocos]Cocos2d-html & Tiled 引擎多加载一块瓷砖致使X坐标不正确","updated":"2018-05-02T11:25:13.447Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-10-27/11.[Cocos]Cocos2d-html & Tiled 引擎多加载一块瓷砖致使X坐标不正确/","excerpt":"记载一次在 Cocos2d-html 引擎中使用 Tiled 的 Bug 发现和解决。 这是我在 Tiled 中设计的图层：我想加载黑色框中的图像，但是我实际加载出来的是红色框中的图像。这看起来就像是 cocos2d-html 引擎在计算水平位置时多往右加了一个格子的位置 …然后这是在浏览器中的图像：好气啊","categories":[{"name":"Cocos2d-js","slug":"Cocos2d-js","permalink":"http://hyjzref.github.io/categories/Cocos2d-js/"}],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://hyjzref.github.io/tags/cocos/"},{"name":"bug","slug":"bug","permalink":"http://hyjzref.github.io/tags/bug/"}]},{"title":"[Cocos] make.exe: *** No rule to make target 错误原因与解决方案","date":"2017-10-17T16:14:00.000Z","path":"posts/2017-10-18/10.[Cocos] make.exe  bug/","text":"记一次 cocos2dx-js Android 打包报错。将能够正确打包的 HelloWorld 工程拷贝到家里的电脑，确保配好环境之后打包的时候报错了，错误信息如下：make.exe: * No rule to make target ‘xxx.cpp’,need ‘xxx.o’ 错误原因：因为工程的路径发生改变，比如E盘移到了D盘，或是像我这样更换了电脑。而之前打包生成的 .o 静态库文件并不会重新编译，所以在打包时导致了在原本的路径找不到对应的依赖文件。解决办法：删除项目中编译后的 obj 文件夹，重新编译一次即可。","slug":"10.[Cocos] make.exe  bug","updated":"2018-01-07T14:21:19.769Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-10-18/10.[Cocos] make.exe  bug/","excerpt":"","categories":[{"name":"Cocos2d-js","slug":"Cocos2d-js","permalink":"http://hyjzref.github.io/categories/Cocos2d-js/"}],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://hyjzref.github.io/tags/cocos/"},{"name":"bug","slug":"bug","permalink":"http://hyjzref.github.io/tags/bug/"}]},{"title":"我的游戏开发日记","date":"2017-10-11T16:00:00.000Z","path":"posts/2017-10-12/9.我的游戏开发日记/","text":"2017.10.12涂鸦时突然脑门一热，胸腔突然跟上燃起滚滚热血，全身突然一个激灵振起，JOJO！（~~老子不做人了！）老子要做游戏了！啊，莫名就开始了。。。2017.11.06 除去玩游戏、看漫画和睡懒觉业余时间是真的不多，不对，这么想想时间还是蛮多的。想来想去决定开始的时候还是选择自己算熟悉的 Cocos 引擎，这将近一个月的时间干这么些事：1.搭建开发环境包括 Cocos 引擎、CocosStudio 编辑器和 ADK、SDK 等；2.在网上寻找下载合适的美术资源； 3.选择游戏工具链：- Tiled:地图编辑器- TexturePacker：图片打包工具；- ShoeBox：图集处理工具，百度“动态图片基地”更好用；- Pdplayer：帧动画编辑器；- 不知名的 bmp 转 png 转换器：可以去掉 bmp 的黑底并且为 png 保留透明像素，真心好用。4.发现了一个 Cocos-html 上运 行Tiled 的 Bug，加载出来的图块计算X格子数会多加上一，emm。。。百度了一圈没想到都没人提到过这个Bug，花了好几个晚上才解决就另开了一篇文章写了。5.花了蛮大的功夫才写了点样子——摇杆控制角色状态变化。（实际编写游戏才发现自己在框架模式上知识的匮乏程度，还需加油啊(・`ω´･)）最后，附上见笑的效果图：打算以后做成一个2D横版闯关游戏，今天就先撤了，人感冒了有点飘~。2017.12.02实力太菜，坑挖在这，哪个时候变强了…再填2018.04.20花了一天半的时间做了一个GalGame的Demo，苦恼于脑子想不出啥剧情。。。","slug":"9.我的游戏开发日记","updated":"2018-05-02T11:25:52.960Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-10-12/9.我的游戏开发日记/","excerpt":"2017.10.12涂鸦时突然脑门一热，胸腔突然跟上燃起滚滚热血，全身突然一个激灵振起，JOJO！（~~老子不做人了！）老子要做游戏了！啊，莫名就开始了。。。2017.11.06 除去玩游戏、看漫画和睡懒觉业余时间是真的不多，不对，这么想想时间还是蛮多的。想来想去决定开始的时候还是选择自己算熟悉的 Cocos 引擎，这将近一个月的时间干这么些事：1.搭建开发环境包括 Cocos 引擎、CocosStudio 编辑器和 ADK、SDK 等；2.在网上寻找下载合适的美术资源；","categories":[{"name":"游戏开发记录","slug":"游戏开发记录","permalink":"http://hyjzref.github.io/categories/游戏开发记录/"}],"tags":[{"name":"开发日记","slug":"开发日记","permalink":"http://hyjzref.github.io/tags/开发日记/"}]},{"title":"[Cocos] cocos2dx-js 3.12 绑定技术浅探","date":"2017-09-28T14:51:00.000Z","path":"posts/2017-09-28/8.[Cocos] cocos2dx-js 3.12 绑定技术浅探/","text":"研究项目代码的时候，发现很多时候大佬的代码一直有一个很神秘的函数调用，这个函数看不到在哪定义也找不到实现。偶然间接触到 JSB(JavaScript Binding) 才恍然大悟。JSB 大概的说是将 JS 与 C++ 绑定起来的通道，感觉摸到了点 JSB 的门道，笔记笔记~1.JS 引擎的脚本绑定框架要了解绑定过程就必须先了解 JS 绑定框架。如图 JS 脚本绑定框架可以分为三层，最底层是 C++ 编写的Cocos2d-x 游戏引擎；往上一层是 JS 引擎 SpiderMonkey 和 JSB 绑定技术，JSB 可以由三部分组成，分别是自动绑定、手动绑定和纯脚本绑定；最高层才是 JS 的 API 和逻辑代码。 2.自动绑定的过程Cocos2dx-js 引擎提供的底层 C++ 代码的调用绝大部分都是通过自动绑定技术实现的，所以要看底层源码还是得了解一下自动绑定。1.)函数注册第一步需要在 AppDelegate.cpp 中的 applicationDidFinishLaunching 函数中进行函数注册，将 C++ 代码注册到 JS 引擎，JS 调用代码时会转换调用对应绑定的 C++ 代码，这里注册了各种类库。2.)函数绑定第二步是将 C++ 函数绑定 JS 函数，在 frameworks\\cocos2d-x\\cocos\\scripting\\js-bindings\\auto 目录下绑定了诸多函数。例如 jsb_cocos2dx_extension_auto.cpp 中就会有12345678910111213141516static JSFunctionSpec funcs[] = &#123; JS_FN(\"setEnabled\", js_cocos2dx_extension_Control_setEnabled, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"getState\", js_cocos2dx_extension_Control_getState, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"sendActionsForControlEvents\", js_cocos2dx_extension_Control_sendActionsForControlEvents, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"setSelected\", js_cocos2dx_extension_Control_setSelected, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"isEnabled\", js_cocos2dx_extension_Control_isEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"needsLayout\", js_cocos2dx_extension_Control_needsLayout, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"hasVisibleParents\", js_cocos2dx_extension_Control_hasVisibleParents, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"isSelected\", js_cocos2dx_extension_Control_isSelected, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"isTouchInside\", js_cocos2dx_extension_Control_isTouchInside, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"setHighlighted\", js_cocos2dx_extension_Control_setHighlighted, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"getTouchLocation\", js_cocos2dx_extension_Control_getTouchLocation, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FN(\"isHighlighted\", js_cocos2dx_extension_Control_isHighlighted, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE), JS_FS_END &#125;;// JS_FN中参数分别为JS函数名，C++函数名，参数个数，访问特性 3.)C++的实现代码最后，一般在,cpp文件中找到实现代码。比方说 2 中的 setEnabled 函数的实现代码就能在 jsb_cocos2dx_extension_auto.cpp 中找到。1234567891011121314151617181920bool js_cocos2dx_extension_Control_setEnabled(JSContext *cx, uint32_t argc, jsval *vp)&#123; JS::CallArgs args = JS::CallArgsFromVp(argc, vp); bool ok = true; JS::RootedObject obj(cx, args.thisv().toObjectOrNull()); js_proxy_t *proxy = jsb_get_js_proxy(obj); cocos2d::extension::Control* cobj = (cocos2d::extension::Control *)(proxy ? proxy-&gt;ptr : NULL); JSB_PRECONDITION2( cobj, cx, false, \"js_cocos2dx_extension_Control_setEnabled : Invalid Native Object\"); if (argc == 1) &#123; bool arg0; arg0 = JS::ToBoolean(args.get(0)); JSB_PRECONDITION2(ok, cx, false, \"js_cocos2dx_extension_Control_setEnabled : Error processing arguments\"); cobj-&gt;setEnabled(arg0); args.rval().setUndefined(); return true; &#125; JS_ReportError(cx, \"js_cocos2dx_extension_Control_setEnabled : wrong number of arguments: %d, was expecting %d\", argc, 1); return false;&#125; 3.深入研究的方向这里作为扩展加分项，以后有需要再进行研究。例如：● Andriod.mk 中会包含所有需要参与编译的 .cpp 文件；● 以及绑定时的转换规则可能需要修改,类型转换、命名空间转换什么的。详见 http://blog.csdn.net/jianglong0156/article/details/45896341","slug":"8.[Cocos] cocos2dx-js 3.12 绑定技术浅探","updated":"2018-02-20T13:45:32.160Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-09-28/8.[Cocos] cocos2dx-js 3.12 绑定技术浅探/","excerpt":"研究项目代码的时候，发现很多时候大佬的代码一直有一个很神秘的函数调用，这个函数看不到在哪定义也找不到实现。偶然间接触到 JSB(JavaScript Binding) 才恍然大悟。JSB 大概的说是将 JS 与 C++ 绑定起来的通道，感觉摸到了点 JSB 的门道，笔记笔记~1.JS 引擎的脚本绑定框架要了解绑定过程就必须先了解 JS 绑定框架。如图 JS 脚本绑定框架可以分为三层，最底层是 C++ 编写的Cocos2d-x 游戏引擎；往上一层是 JS 引擎 SpiderMonkey 和 JSB 绑定技术，JSB 可以由三部分组成，分别是自动绑定、手动绑定和纯脚本绑定；最高层才是 JS 的 API 和逻辑代码。 2.自动绑定的过程Cocos2dx-js 引擎提供的底层 C++ 代码的调用绝大部分都是通过自动绑定技术实现的，所以要看底层源码","categories":[{"name":"Cocos2d-js","slug":"Cocos2d-js","permalink":"http://hyjzref.github.io/categories/Cocos2d-js/"}],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://hyjzref.github.io/tags/cocos/"}]},{"title":"[Cocos] cocos2dx-js 3.12 热更新原理","date":"2017-09-25T14:29:00.000Z","path":"posts/2017-09-25/7.[Cocos] cocos2dx-js 3.12 热更新原理/","text":"这几天终于有时间和精力整理一下自己这段时间的收获了，不得不说 cocos 里的坑点确实有一些，有时候出问题会怀疑这特么是不是引擎的 BUG。总结一下在项目中应用到的热更新的原理，供自己以后回顾。1. cocos2d-x 提供了 AssetsManagerEx 类为了有个整体概念，我们首先来复习一下大纲~。假设服务器已经有一个新的版本，一个理想中的热更新流程应该是：1.下载 version.manifest 文件与本地 version.manifest 文件对比后发现需要进行更新，然后再去下载 detail.manifest 文件同样发现需要进行更新，然后开始下载资源；2.依次下载 assets 字段中有修改或新增的资源，下载完成开始后续处理；3.将下载的远程 .manifest 文件替换本地 .manifest 文件，解压所有的资源文件，热更新完成。————————————————————————在cocos2d-x 3.12中提供给我们开发者们 AssetsManagerEx 类来进行自动更新的逻辑控制，在 jsb_cocos2dx_extension_auto_api.js 中可以发现对应 js 中绑定的类名为 AssetsManager 类，JS的部分基本就是调 API 这里还是说说 cocos c++ 引擎中的实现。放上 AssertManagerEx.cpp 中看起来像是构造函数的部分源码。12345678910111213141516171819// 1. AssetsManagerEx 的构造函数（...表示省略部分代码，下同）AssetsManagerEx::AssetsManagerEx( const std::string&amp; manifestUrl, const std::string&amp; storagePath, const std::string&amp; versionRemoteUrl, const std::string&amp; manifestRemoteUrl): _updateState(State::UNCHECKED),...&#123; // Init variables _eventDispatcher = Director::getInstance()-&gt;getEventDispatcher(); std::string pointer = StringUtils::format(\"%p\", this); _eventName = EventListenerAssetsManagerEx::LISTENER_ID + pointer; _fileUtils = FileUtils::getInstance(); _updateState = State::UNCHECKED; ... initManifests(manifestUrl);&#125;由于没有学过 C++ 所以我也就没花太多心思去研究源码..=A=，不过看起来 AssetsManagerEx 需要这四个参数：&emsp;manifestUrl - 指的是本地 manifest 的相对路径&emsp;storagePath - 下载资源的存放路径&emsp;versionRemoteUrl - 远程 version.manifest 文件路径&emsp;manifestRemoteUrl - 远程 detail.manifest 文件路径这里两个 manifest 文件都是用来管理热更版本的，区别在于 version.manifest 是 detail.manifest 的精简版，查看源码会发现他们的设计逻辑是：先比较远程 version.manifest 文件与本地 version.manifest 中的 groupVersions 字段，只要两者的 groupVersions 字段中有一个 version 不一样就会去下载 detail.manifest 文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445// 2. manifest 文件的比较过程// AssetsManagerEx.cpp if (_localManifest-&gt;versionEquals(_remoteManifest)) // 比较是否相等 &#123; _updateState = State::UP_TO_DATE; dispatchUpdateEvent(EventAssetsManagerEx::EventCode::ALREADY_UP_TO_DATE); &#125; else &#123; ... downloadManifest(); ... &#125;// Manifest.cppbool Manifest::versionEquals(const Manifest *b) const&#123; // Check manifest version if (_version != b-&gt;getVersion()) &#123; return false; &#125; // Check group versions else &#123; std::vector&lt;std::string&gt; bGroups = b-&gt;getGroups(); std::unordered_map&lt;std::string, std::string&gt; bGroupVer = b-&gt;getGroupVerions(); // Check group size if (bGroups.size() != _groups.size()) return false; // Check groups version for (unsigned int i = 0; i &lt; _groups.size(); ++i) &#123; std::string gid =_groups[i]; // Check group name if (gid != bGroups[i]) return false; // Check group version if (_groupVer.at(gid) != bGroupVer.at(gid)) return false; &#125; &#125; return true;&#125;————————————————————————看了这么多，概念应该差不多了解。对开发者而言，最核心的也就是需要配置这两个 .manifest 文件了。可以看到文件中的内容有这么些字段。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 3. manifest 文件的内容// version.manifest&#123; \"engineVersion\" : \"cocos2d-x-3.12\", \"groupVersions\" : &#123; \"1\" : \"1.0.0\", \"2\" : \"1.0.1.1\", \"3\" : \"1.1.1\", \"4\" : \"1.1.3\", \"5\" : \"1.1.4\", \"6\" : \"1.1.7\" &#125;, \"packageUrl\" : \"http://qp.cdn.supernanogame.com/update/xxx/\", \"remoteManifestUrl\" : \"http://qp-conf.supernano.com:8300/xxx/android_detail.manifest\", \"remoteVersionUrl\" : \"http://qp-conf.supernano.com:8300/xxx/android.manifest\", \"searchPaths\" : [], \"version\" : \"1.0.0\"&#125;// sdetail.manifest&#123; \"assets\" : &#123; \"res_common_1.2.24\" : &#123; \"compressed\" : true, \"group\" : \"29\", \"md5\" : \"d06254ffc651d9003bd0b9a3b2153654\", \"path\" : \"res_common_1.2.24.zip\" &#125;, \"src_android_1.2.24\" : &#123; \"compressed\" : true, \"group\" : \"29\", \"md5\" : \"d06254ffc651d9003bd0b9a3b2153654\", \"path\" : \"src_android_1.2.24.zip\" &#125; &#125;, \"engineVersion\" : \"cocos2d-x-3.12\", \"groupVersions\" : &#123; \"1\" : \"1.0.0\", \"2\" : \"1.0.1.1\", \"3\" : \"1.1.1\", \"4\" : \"1.1.3\", \"5\" : \"1.1.4\", \"6\" : \"1.1.7\" &#125;, \"packageUrl\" : \"http://qp.cdn.supernanogame.com/update/xxx/\", \"remoteManifestUrl\" : \"http://qp-conf.supernano.com:8300/xxx/android_detail.manifest\", \"remoteVersionUrl\" : \"http://qp-conf.supernano.com:8300/xxx/android.manifest\", \"searchPaths\" : [], \"version\" : \"1.0.0\"&#125;花点时间看一下这些字段，结合源码对理解流程有一些帮助：assets - 热更的资源信息&ensp;key - 资源名称&emsp;compressed - 值为 true 时，文件被下载后会自动被解压&emsp;group - 该资源对应 groupVersions 中的版本&emsp;md5 - md5值代表资源文件的版本信息&emsp;path - 相对于packageUrl的相对路径groupVersions - 历史版本的列表packageUrl - 远程资源文件的下载路径remoteManifestUrl - 远程 manifest 文件的下载路径remoteVersionUrl - 远程 version 文件的下载路径searchPaths - 搜索路径列表version - 配置文件的版本号源码中还有关于下载失败、下载中途断开等异常情况的处理，这里就不多说了，太懒了~。2.使用 CCEventListenerAssetsManagerEx 类和 CCEventAssetsManagerEx 类得到更新的反馈类似的 JS 中绑定的类名为 EventListenerAssetsManageEx 和 EventAssetsManagerEx。其中前者为流程事件的处理，后者为流程事件的派发。在热更新进行中每当更新状态改变时， AssetsManagerEx 就会派发一个事件给 CCEventAssetsManagerEx。最终 JS 的逻辑代码中可以通过新建一个 EventListenerAssetsManager 对象来接收热更新的状态，以便客户端做对应的处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 4. JS 代码中事件处理器startUpdateProcess:function()&#123; ... this._am.__listener = new jsb.EventListenerAssetsManager(this._am, this._progressEvt.bind(this)); cc.eventManager.addListener(this._am.__listener, 1); this._am.update(); ...&#125;_progressEvt:function(event) &#123; switch (event.getEventCode())&#123; case jsb.EventAssetsManager.ERROR_NO_LOCAL_MANIFEST: cc.log(\"No local manifest file found, skip assets update.\"); this.loadGame(); break; case jsb.EventAssetsManager.UPDATE_PROGRESSION: this._percent = event.getPercent(); this._percentByFile = event.getPercentByFile(); cc.log(this._percent + \"%\"); this.updateProgress(); var msg = event.getMessage(); if (msg) &#123; cc.log(msg); &#125; break; case jsb.EventAssetsManager.ERROR_DOWNLOAD_MANIFEST: this.startUpdateProcess(); break; case jsb.EventAssetsManager.ERROR_PARSE_MANIFEST: cc.log(\"Fail to parse ERROR_PARSE_MANIFEST or Fail to download manifest file\"); this.loadGame(); break; case jsb.EventAssetsManager.ALREADY_UP_TO_DATE: case jsb.EventAssetsManager.UPDATE_FINISHED: cc.log(\"Alreday up to date or Update finished.\"); this.loadGame(); break; case jsb.EventAssetsManager.UPDATE_FAILED: cc.log(\"Update failed. \" + event.getMessage()); __failCount ++; if (__failCount &lt; __maxfailCount) &#123; this._am.downloadFailedAssets(); // 重新下载更新失败的文件 &#125; else &#123; cc.log(\"Reach maximum fail count, exit update process\"); __failCount = 0; this.loadGame(); &#125; break; case jsb.EventAssetsManager.ERROR_UPDATING: cc.log(\"Asset update error: \" + event.getAssetId() + \", \" + event.getMessage()); this.loadGame(); break; case jsb.EventAssetsManager.ERROR_DECOMPRESS: cc.log(event.getMessage()); this.loadGame(); break; default: break; &#125; &#125;,3.实现方案中需要注意的事项有一些小细节能记住就记住吧=___=……● 需要进行更新的文件不应该放在 project.json 中的 jsList 列表中加载。● 热更过程中应可以使用 jsb.fileUtils.getWritablePath() 获取资源存放路径参考：karelgt的博客-&gt;http://karelgt.com/","slug":"7.[Cocos] cocos2dx-js 3.12 热更新原理","updated":"2018-01-07T14:21:27.953Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-09-25/7.[Cocos] cocos2dx-js 3.12 热更新原理/","excerpt":"这几天终于有时间和精力整理一下自己这段时间的收获了，不得不说 cocos 里的坑点确实有一些，有时候出问题会怀疑这特么是不是引擎的 BUG。总结一下在项目中应用到的热更新的原理，供自己以后回顾。1. cocos2d-x 提供了 AssetsManagerEx 类为了有个整体概念，我们首先来复习一下大纲~。假设服务器已经有一个新的版本，一个理想中的热更新流程应该是：1.下载 version.manifest 文件与本地 version.manifest 文件对比后发现需要进行更新，然后再去下载 detail.manifest 文件同样发现需要进行更新，然后开始下载资源；2.依次下载 assets 字段中有修改或新增的资源，下载完成开始后续处理；3.将下载的远程 .manifest 文件替换本地 .manifest 文件，解压所有的资源文件，热更新完成。————————————————————————在cocos2d-x 3.12中提供给我们开发者们 AssetsManagerEx 类来进行自动更新的逻辑控制，在 jsb_cocos2dx_extension_auto_api.js 中可以发现对应 js 中","categories":[{"name":"Cocos2d-js","slug":"Cocos2d-js","permalink":"http://hyjzref.github.io/categories/Cocos2d-js/"}],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://hyjzref.github.io/tags/cocos/"}]},{"title":"[动画感想]大护法中的一些感想-《大护法》","date":"2017-07-22T16:00:00.000Z","path":"posts/2017-07-23/6.[动画感想] 大护法中的一些感想-《大护法》/","text":"下午看完刚上映的国产动画电影《大护法》，一个又一个的想法不停的冒出来，冲得我头昏脑涨，所以特地在这里总结一下。 1.花生人 首先想到花生人是人吗？查看人是如何定义人的，参考百度百科的词条。 生物学上，人被分类为人科人属人种，是一种高级动物。文化人类学上，人被定义为能够使用语言、具有复杂的社会组织与科技发展的生物，尤其是能够建立团体与机构来达到互相支持与协助的目的。哲学上，人是能够自主纪录并自觉重演精神物的生命体。其中生命是宇宙合律精神物在现实中的自我重演；精神物是过去事、物在现实物中的纪录。 总的来说，人的定义很复杂，关于这点世界上有数不清的文献在讨论。这里单从花生人具有人的智慧，具有语言表达能力，具有创造能力，能够使用工具，一般为群居等等这些人类特点的缩影来看，花生人应该就是指的人类了，结合武器的使用来看，应该是中世纪时期。 在这一点成立之后，花生人的寓意就相当清晰了。各种各样的花生人就是对各种不同性格的人的表现。 关于人的讨论，很多动漫中都有讨论到。《大鱼海棠》中认为人的灵魂在人死后会化为一条大鱼，经历重重漂流后，会再度出生于人世。而在《大护法》中，故事开篇很多地方都隐隐提醒着人们思考花生人到底是什么，之后在隐婆的讲述下花生人被看做是一种任人宰割的圈养生物，可以在每一年丰收季从花生人身上收获一种名为黑蛊石的具有剧毒和致幻的物品。国产动画似乎都喜欢把人设定作为一种来世可以再生的存在。鲲重生人世后还是那个鲲，花生人一批死后又有下一批同样被圈养的花生人。往往复复，时间流逝，时代变化了，不变的是人。 2.大护法 刚开始从预告了解到大护法，我以为这会是讲述大护法的传奇经历的故事。然而看完后整部影片中花生人似乎才是主角，大护法和太子只是作为故事的开端和推动者，甚至连结尾都是一个类似姜的蚁猴子在仰望星空若有所思。难免有些失望。 最后面对罗丹的时候说了一大堆话，气势很足，话也很对，但就是觉得这段话安排得有些生硬，表现得不在气氛上。或许大护法也就真的只是打开花生村的人吧。 3.庖丁卯卯 庖卯真的是一个非常具有讽刺意义的角色。最开始见到的时候我就觉得他特别像是被传销机构洗脑的人，一口一个理想、加油。 他给自己的人生目标是一刀取人心脏，这意味他得成为一个杀手。但这与他的实际工作有些出入，单从他现在的表现来看，他一味的拿花生人练刀工，他之后更有可能成为的是刀法娴熟的屠宰者，而不是杀手。而这仅仅只是他想证明自己是庖氏后人。事实上，在他意识到花生人也能被称为人之后开始怀疑自己的所作所为，对自己的过去的工作感到震惊和迷茫。长久以来用所谓的理想麻木自己，却没有去好好看清自己理想的道路，懦弱的待在屠宰房不思改变，那么当现实真正摆在他面前的时候，他所能做也就是呕吐、怀疑人生，然后破罐子破摔和以往一样为吉安老头卖命了。 4.一些吐槽 抛开动画表现，这部影片的血腥和暴力程度足够定位为R18了，能上映真的是奇迹。 火器打在木头上居然也会有火花四溅！？ 杀手罗丹死前说的“妈妈，天要下雨了”…不明所以 太子的山水画…真不愧是13禁","slug":"6.[动画感想] 大护法中的一些感想-《大护法》","updated":"2018-04-20T10:28:02.076Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-07-23/6.[动画感想] 大护法中的一些感想-《大护法》/","excerpt":"下午看完刚上映的国产动画电影《大护法》，一个又一个的想法不停的冒出来，冲得我头昏脑涨，所以特地在这里总结一下。 1.花生人 首先想到花生人是人吗？查看人是如何定义人的，参考百度百科的词条。 生物学上，人被分类为人科人属人种，是一种高级动物。","categories":[{"name":"所得所想","slug":"所得所想","permalink":"http://hyjzref.github.io/categories/所得所想/"}],"tags":[{"name":"感想","slug":"感想","permalink":"http://hyjzref.github.io/tags/感想/"},{"name":"大护法","slug":"大护法","permalink":"http://hyjzref.github.io/tags/大护法/"}]},{"title":"[游戏感想] 莉冈女王的人生哲学-《fault2》","date":"2017-07-21T17:24:36.914Z","path":"posts/2017-07-22/5.[游戏感想] 莉冈女王的人生哲学-《fault2》/","text":"索尔：这之后我该如何生活？ 莉冈：生而活，当不遗余力。 fault2中莉冈女王充满着令我折服的领袖魅力，于是想要写下一些感想。 fault2把贫富差距这个世界的主要矛盾放在了游戏的主舞台上。被父母抛弃的索尔和米尔相依为命。索尔总是把努力“获取”金钱作为逃避妹妹米尔不久后将因病死去这一残酷现实的借口。相反莉冈女王做事极为严苛高效，常有出人意料的疯狂之举。识人常透过细节看本质，能从非常人之思维看待矛盾，步步直逼问题核心。会把“虚度光阴”放在嘴边，行事果断自信，充满着令人折服的领袖气质。 摘取一段游戏内的对话。 索尔：“放弃…吧…，这次是真的无能为力了，反抗药剂师公会，就凭我们根本不够格。米尔你也明白的吧！” 米尔：“但是这样…这样太不公平了吧…哥哥” 索尔：“自我们出生那刻起，不就是已经是不公平的了吗？现在还大惊小怪什么？” 米尔：“话是这么说…” 索尔：“以卵击石，又有什么好处？别活在梦里，没事的…以后我也会继续赚钱的” 米尔：“但是…” 莉冈女王：“汝之所言何其愚蠢。药当耕种如旧。具无天理如是，不必向其屈服。” 露恩：“但是，莉冈小姐…要是他们叫来了同伙回来该怎么办？我们也不能一直陪着他们啊” 莉冈女王：“孤遗一计。米尔，汝之通信书者，可与万众通信否？则从今日起，于其页面之上著写文章，以汝真姓字署之。详尽一切现状，毫无虚假。” 米尔：“这么做又能怎样呢？” 莉冈女王：“自是由斯国之民定夺。使未石沉大海，必有传檄之波涛。药剂师公会横行霸道如是，怒之者绝不在寡。” 露恩：“等一下…表明态度又能怎样？那不是徒生事端吗？” 莉冈女王：“徒生？义正言辞直面恶行，岂谓之徒？泽威茨，汝太过怯懦。任其横行则彼将愈发恣肆，此理孺子皆知。一二人所能为为之事少之又少。是以当先广纳黔首为同志。米尔，汝要呕心沥血，真是之上加以煽动，俱言其实。” 露恩：“但是…这不是让米尔告诉黑社会‘我在这里快来呀’吗？” 索尔：“所以我都说了，不用这么做…，只要我每天工作…努力赚钱即可…如此而已。” 米尔：“但、但是…他们还可能会坐地起价啊…？我们现在的处境太糟糕了，哥哥！” 索尔：“我去做…我去做风险更大的工作就是…比起跟公会对着干要好多了。” 米尔：“哥哥…我求你了…别再牺牲自己了…你也站在我的立场想想啊，你有考虑过，一味依赖着哥哥，什么都做不到的我到底是什么感受吗？！” 索尔：“… 我们这不是无路可走吗…米尔。就是因为我们什么都改变不了，所以才会沦落到这个地步。没问题的…我们两个人不是也好好地一起活到今天了吗…以后也能活下去…” 米尔：“为、为什么…你总是这个样子！不后悔吗？这可是性命攸关的大事啊？！” 索尔：“我只要能赚够让米尔活下去的钱就好…” 莉冈女王：“何要如此狼狈？汝辈似有些误会？所谓苟全性命于不法暴政之选项，本不存在。放弃汝之放弃，如是则更为简易。痛苦则战斗。后悔则抗争。如此而已。好生听取。随波逐流，汝等将无立锥之地。至多不过悄然逐出彼斯坎塔，暴尸荒野。此丧尽天良之事，必不容存于世间。听取来，唯人也，独活则一事无成，卑微之生灵也。如同覆盖四野八荒之膨大魔力。仅有毫厘则不成气候。然其可为神祝魔法巨炎之星火。人理亦同，人与人之有联系，而协同乃生。是以汝要挣扎，汝要求助。以汝羸弱之躯，暴露于世人眼前。煽动布衣之怒火，唤取黔首之同情，兴民生之共鸣，结断金之同心。自太古以降，人以此道铸不可为之事。唯有同心同德，人方能抗暴行，正叛道。此乃自然之理。” 与历史中三国中奸雄想比，莉冈女王身上有着相似的特征。即便处在安逸闲适的环境下也时刻居安思危，以小心谨慎的态度“怀疑”着周围，所谓泰山崩于前而色不变，说的就是这样一种万事皆在考虑的危机思维。索尔、露恩甚至整个国家政府都找不到出路，展露放弃姿态的时候，正如董卓入京，民生哀悼，百官哭诉之时，曹操却能大笑百官懦夫，不知此时才是展露能力的时机，莉冈女王同样一眼看出不用多久彼斯坎塔必定有暴乱，人民将会奋起反抗。 这，大概就是我对自己的憧憬。","slug":"5.[游戏感想] 莉冈女王的人生哲学-《fault2》","updated":"2018-04-20T09:29:32.538Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-07-22/5.[游戏感想] 莉冈女王的人生哲学-《fault2》/","excerpt":"索尔：这之后我该如何生活？ 莉冈：生而活，当不遗余力。","categories":[{"name":"所得所想","slug":"所得所想","permalink":"http://hyjzref.github.io/categories/所得所想/"}],"tags":[{"name":"感想","slug":"感想","permalink":"http://hyjzref.github.io/tags/感想/"},{"name":"fault","slug":"fault","permalink":"http://hyjzref.github.io/tags/fault/"}]},{"title":"[摘抄]一曲云水释禅心","date":"2017-07-16T12:57:00.000Z","path":"posts/2017-07-16/4.[摘抄]一曲云水释禅心/","text":"笔： 白落梅如水良辰，温一壶白月光，在落花深埋的小院，抚一曲《云水禅心》。白日里飘飞的尘埃，此时已散尽，烟云收敛，世事忘机。红尘脂粉皆落幕，鸟雀尽归山林。流水无声，一叶野舟横渡，浮世清波里，已寻不见往事的身影。 闲云悠悠，流水淙淙，这叮咚无意的琴音，让我忘却烟花世情，只念灵台清澈。江南丝竹的清越与空灵，给人一种飘忽不定的美丽与柔情。那些行走江湖、琴萧相伴的日子早已远去。走过风尘的时光，岁月不再温厚，曾几何时，异客已归旧乡，青春也换苍颜。 什么是云？云在万里长空自在飘荡，无根无蒂，没有归宿。随着四时景致，变幻莫测，朝暮不一。时而绚丽如虹，时而洁白似雪；时而浓郁如雾，时而散淡似烟。它的名字叫云，傲然于苍穹之上，千般姿态，万种风情。随缘而聚，随缘而散，一世光阴，了无痕迹。空空而来，空空而去，三千幻象，总是迷离。 何谓水？上善如水，从善如流。水的一生都在谦下，造化众生，滋养万物。不见其形，却闻其音，识其骨。柔弱之水，却有婉约轻灵的韵致。这就是水，可以淘尽悲欢，亦可以洗尽铅华。它流经日月，优雅从容，宁静怡然，无欲无求。 禅心是什么？禅心是午后阳光下的一壶清茗，是苍茫绿野中一树菩提，是似水流年里的一寸光阴，是人生戏剧里的里的一段插曲。禅心是在寂静山林拣尽寒枝，在孤舟柳岸江雪独钓；也是在红尘路上匆匆来往，在风雨江湖快意恩仇。你坐禅内，心在尘外。你处尘间，心依旧可以在禅中。 一个人唯有将锋芒磨尽，才可以真正自在淡然。那时候，便懂得平静地对待人生的聚散离合，接受岁月赠予的苦难和沧桑。曾经绰约的年华，如今看似寥落寡淡，却有了几分风骨，多了一种韵味。唯有这般，才能拥有一颗清醒的禅心，任凭烟云变幻，逝水滔滔，亦不改山河颜色。 《六祖坛经》云：“世人性本清净，万法从自性生；思量一切恶事，即生恶性；思量一切善事，即生善行。如是诸法，在自性中，如天长清，日月常明，为浮云覆盖，上明下暗，忽遇风吹云散，上下俱明，万象皆现。” 每个人最开始都是良善的自己，只因入世久了，经历了太多的事，与太多的人相处，才不再那么慈悲。这是一个从陌生到熟悉，由简单到繁复的过程，也是人生必经的路途。有些人，转过几个岔路口，变重遇初时的自我，拾回过往的简洁和清澈。有些人，百转千回才能够清醒自知。 也许等到那么一天，世事风轻云淡，我们再不必和旧梦一一相认。而整个过程，我们有过得失，多少聚散，多少善恶，亦无须计较。因为我们始终没有丢失真实的自己，能够在朗朗乾坤下坦然地活着，就是岁月的勇者。能够在寂静的午夜，和一弯明月遥遥相望，就是真正的慈悲。 浮生梦幻，皆为泡影，如露如电，似雾似烟。昨日风暖菩提绿，今宵霜染枫叶红。生命就是一场鸿雁的远行，待到春潮消退之时，秋风乍起之日，才懂得归来。那时候，踏遍河山万里，访遍驿路他乡，又怎会不知，真正的释然是放下一切，随遇而安。 南柯一梦，空老山林。芸芸众生费尽心思寻找的桃源，原来不在世外，而是在颜色缤纷的人间。在这里，花落水无声，晓寒烟草迷；在这里，竹林闻鸟语，山寺钟声远。三更风雪，便可让青山白头；一盘棋局，便可定楚汉胜负；一叶扁舟，足以抵达禅的彼岸。 人世间的生灭故事，起落情感，与大自然的荣枯原本相通。王国维词中有这么一句：“君看今年树上花，不是去年枝上朵。”我们以为花落了，还会再开，竟不知，花开了千百次，却不再是从前的朵儿。一棵树的一生，如同人的一世。树是春繁秋萎，而人则是盛年一过，不可重来。 所有的执著，都只是一时的妄念，走过去了，幻灭尽消，便永不复起。走不过去，当为劫数，红尘路上另有一番周折。只有在心中种一株菩提，自省自悟，顿悟顿修，将无常当寻常，将有相当无相，方能真的解脱，似流云来去自由，纵横尽兴。 没有谁知道禅的境界到底是什么，亦不知道该用什么方法去修炼。一个人，只要心存善念，少有欲求，自可减去尘劳，明心见性。《六祖坛经》云：“自性若悟众生是佛。自性若迷佛是众生。自性平等众生是佛。自性邪险佛是众生。”佛缘到了，便瓜熟蒂落，水到渠成。那时候，草木即佛，山石即佛，凡夫即佛，俗子即佛，万物众生皆是佛。 花落无言，流水不语。在清明简净的日子里，当淡了心性，坐幽篁阵里，品潋滟茶汤。看那白衣胜雪的女子，眉目清澈，不施粉黛，抚一把七弦绿绮，唱一曲云水禅心。任萧萧竹叶，悠悠白云，来来去去，聚聚离离。 在周日晚上让自己的内心回归平静的一篇散文，摘抄自 悦读FM - 倾听文字的声音","slug":"4.[摘抄]一曲云水释禅心","updated":"2018-01-07T14:16:49.722Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-07-16/4.[摘抄]一曲云水释禅心/","excerpt":"笔： 白落梅如水良辰，温一壶白月光，在落花深埋的小院，抚一曲《云水禅心》。白日里飘飞的尘埃，此时已散尽，烟云收敛，世事忘机。红尘脂粉皆落幕，鸟雀尽归山林。流水无声，一叶野舟横渡，浮世清波里，已寻不见往事的身影。","categories":[{"name":"摘抄","slug":"摘抄","permalink":"http://hyjzref.github.io/categories/摘抄/"}],"tags":[{"name":"摘抄","slug":"摘抄","permalink":"http://hyjzref.github.io/tags/摘抄/"},{"name":"散文","slug":"散文","permalink":"http://hyjzref.github.io/tags/散文/"},{"name":"禅语","slug":"禅语","permalink":"http://hyjzref.github.io/tags/禅语/"}]},{"title":"[Cocos] Cocos中的Http扫盲学习","date":"2017-07-12T15:31:00.000Z","path":"posts/2017-07-12/3.[Cocos] Cocos中的Http扫盲学习/","text":"1 Http协议每一个HTTP包都分为HTTP头和HTTP体两部分，后者是可选的，而前者是必须的。Http头格式形如 Method Request-URI HTTP-Version CRLFMethod 表示请求方法,一般为GET或POSTRequest-URI 是一个统一资源标识符，用来唯一的标识一个资源HTTP-Version 表示请求的HTTP协议版本CRLF 表示回车和换行 2 GET与POST请求 3 XMLHttpRequest对象XMLHttpRequest对象是Ajax的Web应用程序架构的一项关键功能，它可以同步或异步返回服务器的响应，并且能以文本的形式返回内容。1 创建var xhr = cc.loader.getXMLHttpRequest();在Cocos中通过getXMLHttpRequest()可以获得一个xhr对象。 2 常用属性和函数readyState属性用于获取xhr当前的状态，一般用来检测是否已经收到服务器的返回。0：请求未初始化（还没有调用open方法）。1：请求已经建立，但是还没有发送（还没有调用sned方法）。2：请求已发送，正在处理中。3：请求在处理中，相应中已有部分数据可用了。4：响应已完成，可以获取并使用服务器的响应。 status属性Http请求状态码，一般也用来检测服务器是否返回了正确的数据，常用的有。200：一切正常，对GET和POST请求的应答文档跟在后面。301：客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。304：客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。404：无法找到指定位置的资源。500：服务器遇到了意料不到的情况，不能完成客户的请求。 response属性包含response属性和responseText属性xhr.response1.当请求完成时，此属性才有正确的值。2.xhr.responseType有关：当responseType为””或”text”时，值为””；responseType为其他值时，值为 null。 xhr.responseText1.只有当 responseType 为”text”、””时，xhr对象上才有此属性，此时才能调用xhr.responseText，否则抛错。2.只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串””：请求未完成、请求失败。 onreadystatechange属性这个属性用于设置回调函数，当readyState改变时自动调用。 open()函数open(method, url, asynch, username, password)method：string，表示请求类型，一般为”GET”或”POST”url：string，表示服务器端地址asynch：boolean，表示是否使用异步连接，默认为trueuser：string，如果需要用户名，通过该参数指定password：string，如果需要密码，通过该参数指定 send()函数调用该函数可以将构建好的请求发送到服务端，使用POST请求发送数据时要传入数据。 setRequestHeader()函数setRequestHeader(header, value)设置HTTP请求头中的指定头部header的值为value，此方法需在open方法以后调用 abort()函数停止当前http请求，对应的XMLHttpRequest对象会复位到未初始化的状态 3 代码示例 var req = cc.loader.getXMLHttpRequest(); req.open(&quot;GET&quot;, configUrl); //设置表单中发送的数据编码为“名称/值”对 req.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); req.onreadystatechange = function () { if (req.readyState == 4 &amp;&amp; (req.status == 200 || req.status == 301 || req.status == 304)) { ServerConfigClient.stopTimeOut(); cc.log(&quot;get server config success&quot;); ServerConfigClient.onGetServerConfigReady(req.response); } }; req.send(&quot;&quot;);","slug":"3.[Cocos] Cocos中的Http扫盲学习","updated":"2018-01-07T14:21:16.416Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-07-12/3.[Cocos] Cocos中的Http扫盲学习/","excerpt":"1 Http协议每一个HTTP包都分为HTTP头和HTTP体两部分，后者是可选的，而前者是必须的。Http头格式形如 Method Request-URI HTTP-Version CRLFMethod 表示请求方法,一般为GET或POSTRequest-URI 是一个统一资源标识符，用来唯一的标识一个资源HTTP-Version 表示请求的HTTP协议版本CRLF 表示回车和换行 2 GET与POST请求","categories":[{"name":"Cocos2d-js","slug":"Cocos2d-js","permalink":"http://hyjzref.github.io/categories/Cocos2d-js/"}],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://hyjzref.github.io/tags/cocos/"}]},{"title":"[动画感想]像硝子那样郑重、包容-《声之形》","date":"2017-06-19T18:10:00.000Z","path":"posts/2017-06-20/2.[动画感想]像硝子那样郑重、包容-《声之形》/","text":"声之形讲述的是有听觉障碍的少女西宫硝子和曾经伤害过她的少年石田将也的成长故事。 如果有人问我，是否能原谅曾经欺凌过自己的人？我想我是原谅不了的，总有些过错会在人一辈子中留下痕迹，在我心里没办法将他们当做朋友。在《声之形》之中见过硝子这个角色，我感到震惊和佩服，世界上还有这样包容、温柔的人存在。 西宫家是一个有着很多故事的家庭，即便没有讲述出来，光是看家庭成员都能得出一丝端倪。西宫家只有四个人：硝子、结弦、妈妈、外婆。 硝子：患有先天性听觉障碍，被妈妈送往正常人所在的小学，在学校与同学们有着交流隔阂，久而久之成为了将也的欺凌对象，但总是主动想和班上的人成为朋友。 结弦：喜欢去拍很多动物尸体的照片摆放在家中，目的是希望姐姐不要有自杀的念头，时刻都关注着姐姐的变化。 妈妈：是一个坚强的女人，一个人承担着家庭。另一方面并没有因为硝子有听障就偏袒或是溺爱，反而有些严厉，希望硝子能像正常孩子一样成长。 外婆：心里很清楚家人的心事，但总是微笑着对待她们。在本该清闲的年纪，不去老人俱乐部，而去带着结弦和硝子学习手语。 硝子因为听障以致于表达能力也远不到正常人得水平，使得硝子把许多的想说话都闷在心里，把想法都表现在行动上，然而即便是真诚的对待班上同学，却也因为语言的麻烦和孩童的不成熟使得与周围人格格不入。很难想象一个人在周遭人群都孤立你，作弄你，甚至将生活依赖的助听器作为玩具般毁弃时，还能坚强微笑着面对他们，并保留着友谊之门。这种行为听上去有点像傻子，同龄孩子理解不了这种行为，但若放在大人眼中，恐怕会是一分敬佩一分心疼。拥有这样强大的内心，需要经历一种怎样的童年，需要忍受多大的不幸。即便是已经成年的我，想必也是达不到这种境界的。 现在的社会信息爆炸，处处充满着理想化又难以实现的浮躁讯息，娱乐精神似乎成为这个时代主流的风向标，人们待人处事会加一份玩笑的戏谑在其中，似乎这样的行为更符合这个和平的时代。动画中两度出现硝子笔谈用笔记本落入水中，我总以为硝子会生气的不了了之，但她选择的却总是毫不犹豫地进入水中寻找笔记本，不在乎全身上下湿个透。在我多少次以为硝子会忍耐不住生气或是坚持不住哭泣时，她总是能微笑着认真的做着正确的事。处事的郑重与坚定深深锤击到了我的内心深处。回想起自己曾经那些敢想而未敢做的事，心里有一分惭愧。 我禁不住地想，若是能让改变自己得像硝子那样，在这之后我能否让自己活得更自在、更真实。能否以一种全新更好的姿态来面对自己。见识过这样一种处世的态度，使得我心中充满了想要改变自己的想法，想让自己变得想让自己变得平静，不再焦虑不安；想让自己活得自由，不再受到内心的束缚。 我向往的，便是像硝子那样，微笑面对人生。","slug":"2.[动画感想]像硝子那样郑重、包容-《声之形》","updated":"2018-01-07T14:20:26.705Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-06-20/2.[动画感想]像硝子那样郑重、包容-《声之形》/","excerpt":"声之形讲述的是有听觉障碍的少女西宫硝子和曾经伤害过她的少年石田将也的成长故事。 如果有人问我，是否能原谅曾经欺凌过自己的人？我想我是原谅不了的，总有些过错会在人一辈子中留下痕迹，","categories":[{"name":"所得所想","slug":"所得所想","permalink":"http://hyjzref.github.io/categories/所得所想/"}],"tags":[{"name":"感想","slug":"感想","permalink":"http://hyjzref.github.io/tags/感想/"},{"name":"声之形","slug":"声之形","permalink":"http://hyjzref.github.io/tags/声之形/"}]},{"title":"[Cocos] JavaScript基础","date":"2017-05-13T12:11:51.000Z","path":"posts/2017-05-13/1.[Cocos] JavaScript基础/","text":"一. DOM、BOM和ECMAScript的关系ECMAScript提供了js的语法和基本对象。 DOM提供了可以处理html网页上所有元素的接口。 BOM提供了与浏览器进行交互的方法和接口。 二. EMCAScriptEMCAScript作为js的核心，大部分语法与Java相似。以下着重于ES的特点： 数据类型细分为三类：基本类型： String：字符串，例如”xxx” Number：数字类型，es中Number既可以表示整数（32位或64位）也可以表示浮点数和八、十六进制数 Boolean：布尔值，有两个值true和false 特殊类型： Null：只有一个专用值null，表示不存在的对象 Undefined：同样只有一个专用值，即undefined，声明的变量未初始化时默认值为undefined 对象类型： Object、Array等 函数：函数是es中非常重要的一部分，函数的基本语法是： function functionName(arg0,arg1,...argN){ statements } 函数有两种常见的声明方式： // 正常方式： function sayHi(sName, sMessage) { alert(&quot;Hello &quot; + sName + sMessage); } sayHi(&quot;John&quot;, &quot;Tom&quot;); // FUNCTION方式： var sayHi = new Function(&quot;sName&quot;, &quot;sMessage&quot;, &quot;alert(\\&quot;Hello \\&quot; + sName + sMessage);&quot;); sayHi(&quot;John&quot;, &quot;Tom&quot;); 在FUNCTION方式中，每个 arg 都是一个参数，最后一个参数是函数主体（要执行的代码）。这些参数必须是字符串。FUNCTION方式比正常方式要慢许多，一般考虑正常方式。 可以看出，函数名只是指向函数对象的引用值，可以作为参数传递。甚至可以使两个变量指向同一个函数。 因此可以得到js中的扩展函数，例如为Number扩展： Number.prototype.toHexString = function() { return this.toString(16); }; 在此环境中，关键字 this 指向 Number 的实例，因此可完全访问 Number 的所有方法。有了这段代码，可实现下面的操作： var iNum = 15; alert(iNum.toHexString()); //输出 &quot;F&quot; 函数的参数：","slug":"1.[Cocos] JavaScript基础","updated":"2018-01-07T14:18:58.929Z","comments":true,"link":"","permalink":"http://hyjzref.github.io/posts/2017-05-13/1.[Cocos] JavaScript基础/","excerpt":"一. DOM、BOM和ECMAScript的关系ECMAScript提供了js的语法和基本对象。 DOM提供了可以处理html网页上所有元素的接口。 BOM提供了与浏览器进行交互的方法和接口。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hyjzref.github.io/categories/JavaScript/"}],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://hyjzref.github.io/tags/cocos/"}]}]}